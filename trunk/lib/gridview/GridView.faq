TGridView component for Borland Delphi
Copyright (C) 1997-2001 Роман М. Мочалов

E-mail: roman@sar.nnov.ru, checker@mail.ru
WWW: http://www.sar.nnov.ru/~roman/download/GridView.zip

Исправления: (с) 2002 Компанец Илья, iluha@convex.ru

Вопросы и ответы по использованию компонента TGridView
------------------------------------------------------

Q: Я меняю названия колонок, но названия секций заголовка не изменяются
   автоматически, ходя AutoSynchronize выставлено в True. В чем дело?
A: По умолчанию при синхронизации заголовка с колонками выравнивается только
   количество секций с количеством колонок. Для полной синхронизации, включая
   включая текст заголовка и выравнивание текста, необходимо установить в
   True свойство Header.FullSynchronizing.

Q: Мне нужно сначала заполнить таблицу, затем ее редактировать. В примере,
   идущим вместе с компонентом, это реализовано, но как то непонятно,
   вернее понятно как, но непонятно зачем все делается через события.
   Есть ли возможность сделать все это через какие нибудь свойства.
A: Все дело в том, что компонент предназначен _ТОЛЬКО_ для отображения данных,
   а не их хранения. Предполагается, что данные уже есть (например, какой-либо
   список, массив, структура как в примере с WMF и т.п.) и надо их отобразить.
   Т.о. компонент _НЕ_ хранит строки ячеек, и говорить о его заполнении нельзя. 
   Для примера можно взять аналогию TCustomGrid и TStringGrid - тут компонент
   TGridView будет выступать в качестве TCustomGrid со всеми вытекающими
   последствиями.

A: А почему нет MultiSelect?
Q: По той же самой причине. Для реализации MultiSelect (а заодно и разной 
   высоты строк), необходимо хранить список строк с флагами выделения.
   GridView такого списка не хранит, а значит, негде хранить информацию о
   выделенных строках, а следовательно, нет и MultiSelect.

Q: Зачем нужны cобытия такие специфические события OnGetCheckIndent,
   OnGetCellImageIndent, OnGetCellTextIndent. Если можно, приведите пример
   использования.
A: Эти функции задают смещения при отрисовке содержимого ячеек. Например,
   с помощью этих функций можно легко организовать отображение древовидной
   структуры (как в MS Internet News), для чего:
     1. Указать в OnGetCheckKind, что в качестве картинки флажка первой
        колонки будет картинка пользователя:
          if Cell.Col = 0 then CheckKind := gsUserDefine;
     2. Возвратить в OnGetcheckImage в качестве картинки флажка изображение
        "+" или "-" для закрытого или раскрытого узла:
          if Узел_раскрыт then
            CheckImage.Assign(Картинка_раскрытого_узла)
          else
            CheckImage.Assign(Картинка_закрытого_узла);
     3. Увеличить в OnGetCheckIndent для первой колонки значение смещения
        по горизонтали в соотвествии с уровнем узла:
          if Cell.Col = 0 then Indent.X := Indent.X + 16 * Уровень_узла.

Q: У меня медленный компьютер. Можно ли повысить как-нибудь скорость
   отрисовки таблицы?
A: Вот несколько советов:
   - Если в событии OnGetCellText долго производится синхронный перевод
     данных в строку для отображения, то можно сделать буфер строк для
     ячеек таблицы и заполнить его один раз перед работой (например так,
     как это сделано в TStringGrid). 
   - Если надо раскрашивать ячейки в разные цвета, то следует помнить, что
     перед отрисовкой ячейке автоматически назначаются цвета по умолчанию
     (фон, шрифт). Если не надо менять цвет ячейки, то свойство Canvas в
     событии OnGetCellColors лучше не трогать.
   - Свойства EndEllipsis и Column.MultiLine влияют на метод отрисовки
     текста ячейки. Если хотя бы одно из них выставлено в True, то для
     отрисовки текста вызывается DrawTextEx, в противном случае - ExtTextOut.
     Первая функция рисует значительно медленнее. К сведению - стандартные
     компоненты TStringGrid и TDBGrid используют функцию ExtTextOut.


Q: Я добавляю в RunTime несколько колонок и секции в заголовок. Колонки
   добавились, а вот секции - нет. В чем может быть дело?
A: В значении свойства Header.AutoSynchronize. Если оно установлено в True,
   то при любом изменении колонок происходит выравнивание количества колонок
   и нижних секций заголовка. Т.о. как только добавляется очередная колонка,
   то для нее автоматически добавляется секция заголовка. А т.к. для всех
   колонок уже есть секции, то новые секции, добавленные вручную, удаляются.


Q: Я обновил данные, которые отображаются таблицей, и вызвал InvalidateGrid.
   Вся таблица обновилась, а текст в строке редактирования - нет. Почему?
A: Строка ввода получает текст для редактирования только в начале
   редактирования и ничего не знает об изменении во время редактирования.
   Метод InvalidateGrid перерисовыает таблицу, но не изменяет текст строки
   ввода. Обновлять содержимое строки ввода при обновлении данных таблицы
   необходимо вручную, вызвав метод UpdateEditContents.


Q: Мне надо сохранить данные, введенные в строке ввода, не переходя на
   другую ячейку. Как мне это сделать?
A: Вызвать UpdateEditText или Editing := False. Во втором случае строка
   ввода будет погашена, если AlwaysEdit не установлено в True (так
   делает напрмер TDBGrid).


(C) 1997-2001 Роман М. Мочалов

